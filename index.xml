<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aamer Paul</title>
    <link>https://aamernabi.github.io/</link>
    <description>Recent content on Aamer Paul</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Jul 2025 10:24:00 +0530</lastBuildDate>
    <atom:link href="https://aamernabi.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>What&#39;s new in Spring Boot 4.0? A Look Ahead</title>
      <link>https://aamernabi.github.io/posts/spring-boot-4.0/</link>
      <pubDate>Thu, 24 Jul 2025 10:24:00 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/spring-boot-4.0/</guid>
      <description>&lt;p&gt;The Spring ecosystem is constantly evolving to provide developers with the best tools for building modern, robust applications. With the upcoming release of Spring Framework 7.0, the community is eagerly anticipating the next major iteration of Spring Boot: version 4.0.&lt;/p&gt;&#xA;&lt;p&gt;Spring Boot 4.0 is a major release of the Spring Boot framework, introducing significant enhancements for developers.&lt;/p&gt;&#xA;&lt;p&gt;Key features and improvements in Spring Boot 4 includes:&lt;/p&gt;&#xA;&lt;h2 id=&#34;core-enhancements&#34;&gt;Core Enhancements&lt;/h2&gt;&#xA;&lt;p&gt;Spring Boot 4.0 is built upon &lt;strong&gt;Spring Framework 7.0&lt;/strong&gt; which is major upcoming release of Spring Framework (projected for General Availability in November 2025).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Controlling Inheritance with Java&#39;s Sealed Classes and Interfaces</title>
      <link>https://aamernabi.github.io/posts/java-sealed-interface/</link>
      <pubDate>Tue, 02 Jul 2024 16:25:32 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/java-sealed-interface/</guid>
      <description>&lt;p&gt;Introduced as a standard feature in Java 17, &lt;strong&gt;sealed classes&lt;/strong&gt; and &lt;strong&gt;sealed interfaces&lt;/strong&gt; give you precise control over your class hierarchies. By declaring a class or interface as &lt;code&gt;sealed&lt;/code&gt;, you can restrict which other classes or interfaces are allowed to extend or implement it.&lt;/p&gt;&#xA;&lt;p&gt;This feature is a powerful tool for domain modeling, enhancing security, and working with pattern matching in &lt;code&gt;switch&lt;/code&gt; expressions.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-are-sealed-classes&#34;&gt;What are Sealed Classes?&lt;/h2&gt;&#xA;&lt;p&gt;A &lt;strong&gt;sealed class&lt;/strong&gt; restricts which other classes can inherit from it. This provides better control over the class hierarchy, making your code more robust and maintainable.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding Functional Interfaces in Java</title>
      <link>https://aamernabi.github.io/posts/java-functional-interface/</link>
      <pubDate>Tue, 26 Mar 2024 21:25:32 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/java-functional-interface/</guid>
      <description>&lt;p&gt;A &lt;strong&gt;functional interface&lt;/strong&gt; in Java is an interface that contains exactly one abstract method. Introduced in Java 8, they are the backbone of lambda expressions and the Stream API, enabling a more functional style of programming. They are also known as &lt;strong&gt;Single Abstract Method (SAM)&lt;/strong&gt; interfaces.&lt;/p&gt;&#xA;&lt;p&gt;To ensure an interface is a functional interface, you can use the &lt;code&gt;@FunctionalInterface&lt;/code&gt; annotation. The compiler will then trigger an error if the interface does not meet the requirements.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Deep Dive into the Java Stream API</title>
      <link>https://aamernabi.github.io/posts/deep-dive-into-java-stream-api/</link>
      <pubDate>Mon, 07 Jun 2021 18:12:23 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/deep-dive-into-java-stream-api/</guid>
      <description>&lt;p&gt;The &lt;strong&gt;Stream API&lt;/strong&gt;, introduced in Java 8, is a powerful tool for processing sequences of elements. It provides a functional approach to working with collections and arrays, allowing for expressive and efficient data manipulation. Streams don&amp;rsquo;t store data; instead, they operate on a data source, such as a &lt;code&gt;Collection&lt;/code&gt; or an array, and enable aggregate operations.&lt;/p&gt;&#xA;&lt;h2 id=&#34;core-concepts&#34;&gt;Core Concepts&lt;/h2&gt;&#xA;&lt;p&gt;A stream pipeline consists of three parts:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;A source&lt;/strong&gt;: Where the stream originates from (e.g., a &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, or array).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Zero or more intermediate operations&lt;/strong&gt;: These transform the stream into another stream. Examples include &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, and &lt;code&gt;sorted&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;A terminal operation&lt;/strong&gt;: This produces a result or a side-effect, and triggers the execution of the pipeline. Examples include &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;collect&lt;/code&gt;, and &lt;code&gt;reduce&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;One of the key features of streams is &lt;strong&gt;laziness&lt;/strong&gt;. Intermediate operations are not executed until a terminal operation is invoked. This allows the Stream API to optimize the execution of the pipeline.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Thread-Safe Counters in Java: A Deep Dive into AtomicInteger</title>
      <link>https://aamernabi.github.io/posts/thread-safe_counters_in_java_atomicinteger/</link>
      <pubDate>Tue, 19 Jan 2021 10:41:26 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/thread-safe_counters_in_java_atomicinteger/</guid>
      <description>&lt;p&gt;When building multithreaded applications in Java, ensuring data integrity is crucial. A common challenge arises when multiple threads need to update a shared counter. Without proper synchronization, you can encounter race conditions, leading to incorrect results. This is where &lt;code&gt;AtomicInteger&lt;/code&gt; comes to the rescue.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;AtomicInteger&lt;/code&gt; is a class from the &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; package that provides a thread-safe way to perform atomic operations on an integer value. Unlike traditional locking mechanisms (e.g., &lt;code&gt;synchronized&lt;/code&gt; blocks), &lt;code&gt;AtomicInteger&lt;/code&gt; uses low-level hardware instructions to achieve thread safety with higher performance.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Deep Dive into Java&#39;s BlockingQueue</title>
      <link>https://aamernabi.github.io/posts/java-blocking-queue/</link>
      <pubDate>Mon, 27 Jul 2020 20:09:10 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/java-blocking-queue/</guid>
      <description>&lt;p&gt;A &lt;code&gt;BlockingQueue&lt;/code&gt; in Java is a thread-safe queue that simplifies concurrency management by providing blocking operations. It&amp;rsquo;s a crucial tool for building robust multi-threaded applications, especially for implementing producer-consumer scenarios.&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-do-we-need-blockingqueue&#34;&gt;Why Do We Need &lt;code&gt;BlockingQueue&lt;/code&gt;?&lt;/h2&gt;&#xA;&lt;p&gt;In multi-threaded applications, it&amp;rsquo;s common to have a scenario where one or more threads (Producers) are generating data, and one or more other threads (Consumers) are processing that data. This is known as the &lt;strong&gt;producer-consumer problem&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mastering Asynchronous Programming with Java&#39;s CompletableFuture</title>
      <link>https://aamernabi.github.io/posts/java-completable-future/</link>
      <pubDate>Mon, 27 Jul 2020 12:09:10 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/java-completable-future/</guid>
      <description>&lt;p&gt;Introduced in Java 8, &lt;code&gt;CompletableFuture&lt;/code&gt; is a powerful class for asynchronous programming. It extends the traditional &lt;code&gt;Future&lt;/code&gt; interface with a rich set of features for composing, combining, and handling asynchronous tasks, enabling you to write non-blocking, highly concurrent applications with ease.&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-completablefuture&#34;&gt;Why &lt;code&gt;CompletableFuture&lt;/code&gt;?&lt;/h2&gt;&#xA;&lt;p&gt;Before &lt;code&gt;CompletableFuture&lt;/code&gt;, Java&amp;rsquo;s &lt;code&gt;Future&lt;/code&gt; was limited. You could start an asynchronous task, but you had to block your main thread using &lt;code&gt;get()&lt;/code&gt; to retrieve the result. This defeated the purpose of non-blocking code.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding Java&#39;s hashCode() and equals() Contract</title>
      <link>https://aamernabi.github.io/posts/java-hashcode/</link>
      <pubDate>Sun, 26 Jul 2020 23:03:02 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/java-hashcode/</guid>
      <description>&lt;p&gt;In Java, the &lt;code&gt;hashCode()&lt;/code&gt; method, inherited from the &lt;code&gt;Object&lt;/code&gt; class, plays a crucial role in the efficient functioning of hash-based collections like &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, and &lt;code&gt;Hashtable&lt;/code&gt;. It generates an integer hash code value for an object, which is used to determine the &amp;ldquo;bucket&amp;rdquo; where the object should be stored.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-hashcode-and-equals-contract&#34;&gt;The &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt; Contract&lt;/h2&gt;&#xA;&lt;p&gt;The most important concept to understand is the contract between &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;If two objects are equal according to the &lt;code&gt;equals(Object)&lt;/code&gt; method, then calling the &lt;code&gt;hashCode()&lt;/code&gt; method on each of the two objects must produce the same integer result.&lt;/li&gt;&#xA;&lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal according to the &lt;code&gt;equals(Object)&lt;/code&gt; method, then calling the &lt;code&gt;hashCode()&lt;/code&gt; method on each of the two objects must produce distinct integer results. However, producing distinct hash codes for unequal objects may improve the performance of hash tables.&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;In simple terms: &lt;strong&gt;equal objects must have equal hash codes.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding Fail-Fast vs. Fail-Safe Iterators in Java</title>
      <link>https://aamernabi.github.io/posts/java-fail-fast-vs-fail-safe-iterators/</link>
      <pubDate>Mon, 20 Jul 2020 15:44:00 +0530</pubDate>
      <guid>https://aamernabi.github.io/posts/java-fail-fast-vs-fail-safe-iterators/</guid>
      <description>&lt;p&gt;When working with collections in Java, you&amp;rsquo;ll often use iterators to traverse through their elements. However, not all iterators are created equal. Two common types you&amp;rsquo;ll encounter are &lt;strong&gt;fail-fast&lt;/strong&gt; and &lt;strong&gt;fail-safe&lt;/strong&gt; iterators. Understanding the difference between them is crucial for writing robust and error-free code.&lt;/p&gt;&#xA;&lt;h2 id=&#34;fail-fast-iterators&#34;&gt;Fail-Fast Iterators&lt;/h2&gt;&#xA;&lt;p&gt;Fail-fast iterators immediately throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if the collection is structurally modified (i.e., elements are added or removed) at any time after the iterator is created, except through the iterator&amp;rsquo;s own &lt;code&gt;remove()&lt;/code&gt; method.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About Me</title>
      <link>https://aamernabi.github.io/about/</link>
      <pubDate>Sat, 18 Jul 2020 14:40:14 +0530</pubDate>
      <guid>https://aamernabi.github.io/about/</guid>
      <description>&lt;p&gt;I’m a Software Engineer with 8+ years of experience in designing and building scalable mobile and backend applications. My core expertise lies in Mobile app development, and I have successfully delivered multiple mobile apps using native Android development (Java and Kotlin), Flutter and Ionic.&lt;/p&gt;&#xA;&lt;p&gt;Over the years, I’ve expanded my skill set beyond mobile to include backend development, with hands-on experience in Spring Boot 3, Spring Cloud, microservices architecture, and Node.js. The full-stack capability allows me to contribute across the entire product lifecycle—from UI/UX to scalable backend systems.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
